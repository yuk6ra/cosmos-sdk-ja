---
sidebar_position: 1
---

# Transaction Lifecycle

:::note Synopsis
このドキュメントでは、トランザクションの作成から確定したステート変更までのライフサイクルについて説明します。トランザクションの定義は、[別のドキュメント](../core/01-transactions.md)で説明されています。このトランザクションは`Tx`と呼ばれます。
:::

:::note Pre-requisite Readings

* [Anatomy of a Cosmos SDK Application](./00-app-anatomy.md)
:::

## Creation

### Transaction Creation

主要なアプリケーションインターフェースの1つは、コマンドラインインターフェースです。トランザクション`Tx`は、ユーザーがコマンドラインから以下の形式でコマンドを入力することで作成されます。`[command]`にはトランザクションの種類、`[args]`には引数、および`[flags]`にはガス価格などの設定を指定します。

```bash
[appname] tx [command] [args] [flags]
```

このコマンドはトランザクションを自動的に**作成**し、アカウントの秘密鍵を使用して**署名**し、指定したピアノードに**ブロードキャスト**します。

トランザクションの作成にはいくつかの必須およびオプションのフラグがあります。`--from`フラグは、トランザクションの発信元となる[アカウント](./03-accounts.md)を指定します。たとえば、コインを送信するトランザクションの場合、指定した`from`アドレスから資金が引き出されます。

#### Gas and Fees

さらに、ユーザーは[手数料](./04-gas-fees.md)としていくら支払うかを示すために、いくつかの[フラグ](../core/07-cli.md)を使用することができます。

* `--gas`は、トランザクション`Tx`が消費する[ガス](./04-gas-fees.md)、つまり計算リソースの量を指します。ガスはトランザクションに依存し、実行まで正確に計算されるわけではありませんが、`--gas`の値として`auto`を指定することで推定することができます。
* `--gas-adjustment`（オプション）は、ガスを過小評価しないために`gas`をスケーリングするために使用できます。たとえば、ユーザーはガス調整を1.5として指定して、推定ガスの1.5倍を使用できます。
* `--gas-prices`は、ユーザーがガス1単位あたりにいくら支払うかを指定します。これはトークンの1つまたは複数の通貨単位で指定できます。例えば、`--gas-prices=0.025uatom, 0.025upho`は、ユーザーがガス1単位あたりに0.025uatomと0.025uphoを支払う意志があることを示します。
* `--fees`は、ユーザーが合計いくらの手数料を支払う意志があるかを指定します。
* `--timeout-height`は、トランザクションが特定の高さを超えてコミットされないようにするためのブロックタイムアウトの高さを指定します。

支払われる手数料の最終的な値は、ガスにガス価格を掛けたものです。言い換えれば、`手数料 = ceil(ガス * ガス価格)`です。したがって、ガス価格または逆にガスを使用して手数料を計算できるため、ユーザーはそのうちの1つだけを指定します。

後で、バリデータは与えられたまたは計算された`gas-prices`と、ローカルの`min-gas-prices`を比較して、トランザクションを自分のブロックに含めるかどうかを決定します。`Tx`の`gas-prices`が十分に高くない場合、トランザクションは拒否されるため、ユーザーはより多く支払うインセンティブがあります。

#### CLI Example

アプリケーション`app`のユーザーは、次のコマンドをCLIに入力して、`senderAddress`から`recipientAddress`へ1000uatomを送信するトランザクションを生成できます。このコマンドでは、支払う意志のあるガスの量が指定されています：自動推定値を1.5倍にスケーリングし、ガス1単位あたりの価格を0.025uatomとしています。

```bash
appd tx send <recipientAddress> 1000uatom --from <senderAddress> --gas auto --gas-adjustment 1.5 --gas-prices 0.025uatom
```

#### Other Transaction Creation Methods

コマンドラインはアプリケーションと対話する簡単な方法ですが、`Tx`は[gRPCまたはRESTインターフェース](../core/06-grpc_rest.md)、またはアプリケーション開発者によって定義された他のエントリーポイントを使用して作成することもできます。ユーザーの視点からは、対話はWebインターフェースまたは使用しているウォレットに依存します（たとえば、[Lunie.io](https://lunie.io/#/)を使用して`Tx`を作成し、Ledger Nano Sで署名することによる`Tx`の作成）。

## Addition to Mempool

各フルノード（CometBFTを実行中）は、`Tx`を受信するとアプリケーションレイヤに対して[ABCIメッセージ](https://docs.cometbft.com/v0.37/spec/p2p/messages/)である`CheckTx`を送信し、`abci.ResponseCheckTx`を受け取ります。`Tx`がチェックに合格する場合、それはノードの[**Mempool**](https://docs.cometbft.com/v0.37/spec/p2p/messages/mempool/)に保持されます。Mempoolは各ノードごとに固有のメモリ内プールであり、ブロックに含めるため保留中のトランザクションを格納します。正直なノードは、`Tx`が無効であると判明した場合、それを破棄します。合意の前に、ノードは受信したトランザクションを継続的にチェックし、ピアにゴシップします。

### Types of Checks

フルノードは、`CheckTx`中に`Tx`に対してステートのない（stateless）チェックとステートのある（stateful）チェックを実行し、無駄な計算を避けるためにできるだけ早く無効なトランザクションを特定して拒否することを目指しています。

**_stateless_** チェックは、ノードがステートにアクセスする必要がないため、軽量クライアントやオフラインノードでも実行でき、したがって計算コストが低く済みます。ステートのないチェックには、アドレスが空でないこと、非負の数値が強制されること、および他の定義で指定されたロジックが含まれます。

**_stateful_** チェックは、コミットされたステートに基づいてトランザクションとメッセージを検証します。例として、関連する値が存在し取引可能であること、アドレスに十分な資金があること、および送信者が承認されているか正しい所有権を持っていることを確認します。任意の時点で、フルノードは通常、アプリケーションの内部ステートの[複数のバージョン](../core/00-baseapp.md#state-updates)を異なる目的のために持っています。たとえば、ノードはトランザクションの検証プロセス中にステート変更を実行しますが、クエリに答えるためには最後にコミットされたステートのコピーが必要です。未確定の変更があるステートで応答すべきではありません。

フルノードは`Tx`を検証するために`CheckTx`を呼び出し、これにはステートのない（stateless）チェックとステートのある（stateful）チェックの両方が含まれます。さらなる検証は後で[`DeliverTx`](#delivertx)段階で行われます。`CheckTx`はいくつかのステップを経ており、`Tx`のデコードから始まります。


### Decoding

アプリケーションがアンダーリングのコンセンサスエンジン（例：CometBFT）から`Tx`を受信すると、`Tx`はまだその[エンコードされた](../core/05-encoding.md)`[]byte`形式のままであり、処理されるためにはアンマーシャルされる必要があります。その後、[`runTx`](../core/00-baseapp.md#runtx-antehandler-runmsgs-posthandler)関数が`runTxModeCheck`モードで呼び出され、この関数はすべてのチェックを実行しますが、メッセージの実行とステートの変更の書き込みの前に終了します。

### ValidateBasic (deprecated)

メッセージ（[`sdk.Msg`](../core/01-transactions.md#messages)）は、トランザクション（`Tx`）から抽出されます。モジュール開発者が実装する`sdk.Msg`インターフェースの`ValidateBasic`メソッドは、各トランザクションに対して実行されます。
明らかに無効なメッセージを破棄するために、`BaseApp`タイプはメッセージの処理の非常に早い段階で`ValidateBasic`メソッドを[`CheckTx`](../core/00-baseapp.md#checktx)および[`DeliverTx`](../core/00-baseapp.md#delivertx)トランザクションで呼び出します。
`ValidateBasic`は、**ステートレス**チェック（ステートへのアクセスを必要としないチェック）のみを含めることができます。

:::warning
メッセージの`ValidateBasic`メソッドは、それぞれの対応する[`Msg`サービス](../building-modules/03-msg-services.md#Validation)で直接メッセージを検証することを推奨するために廃止されました。

詳細については、[RFC 001](https://docs.cosmos.network/main/rfc/rfc-001-tx-validation)を参照してください。
:::

:::note
`BaseApp`は、そのメソッドを実装するメッセージに対して`ValidateBasic`をまだ呼び出し、後方互換性を保っています。
:::

#### Guideline

`ValidateBasic`はもはや使用されるべきではありません。メッセージの検証は、モジュールのMsgサーバーでメッセージを処理する際に、`Msg`サービス内で行うべきです。

### AnteHandler

`AnteHandler`は任意ですが、実際には非常に頻繁に使用され、署名の検証、ガスの計算、手数料の差し引きなど、ブロックチェーントランザクションに関連する他のコアな操作を実行するために使用されます。

キャッシュされたコンテキストのコピーが`AnteHandler`に提供され、トランザクションタイプに指定された限定的なチェックを実行します。コピーを使用することで、`AnteHandler`は最後にコミットされた状態を変更せずに`Tx`のステートフルなチェックを行い、実行が失敗した場合に元に戻すことができます。

例えば、[`auth`](https://github.com/cosmos/cosmos-sdk/tree/main/x/auth/spec)モジュールの`AnteHandler`は、シーケンス番号のチェックと増分、署名とアカウント番号のチェック、トランザクションの最初の署名者から手数料を差し引くなどを行います。すべてのステート変更は`checkState`を使用して行われます

### Gas

[`Context`](../core/02-context.md)は`GasMeter`を保持し、`Tx`の実行中に使用されるガスの量を追跡します。`Tx`のためにユーザーが提供したガスの量は`GasWanted`として知られています。実行中に消費されるガスの量である`GasConsumed`が、いつでも`GasWanted`を超える場合、実行は停止し、ステートのキャッシュコピーに対する変更はコミットされません。それ以外の場合、`CheckTx`は`GasUsed`を`GasConsumed`と等しく設定し、その結果を返します。ガスと手数料の値を計算した後、バリデータノードは、ユーザーが指定した`gas-prices`がローカルで定義された`min-gas-prices`よりも大きいかどうかを確認します。

### Discard or Addition to Mempool

`CheckTx`の実行中にいかなる段階でも`Tx`が失敗すると、それは破棄され、トランザクションのライフサイクルはそこで終了します。それ以外の場合、`CheckTx`を成功裏に通過すると、デフォルトのプロトコルではピアノードに中継され、Mempoolに追加されるため、`Tx`は次のブロックに含まれる候補となります。

**メンプール**は、すべてのフルノードによって見られるトランザクションを追跡するためのものです。フルノードは、最後に見た`mempool.cache_size`個のトランザクションをメンプールキャッシュとして保持し、リプレイ攻撃を防ぐための第一の防御線としています。理想的には、`mempool.cache_size`はすべてのトランザクションをカバーできるだけの大きさです。メンプールキャッシュがすべてのトランザクションを追跡するのに十分な大きさでない場合、`CheckTx`はリプレイされたトランザクションを特定して拒否する責任があります。

現在存在する予防策には、手数料と`sequence`（nonce）カウンターが含まれ、リプレイされたトランザクションと同一だが有効なものと区別します。攻撃者が多数のコピーの`Tx`でノードをスパムしようとする場合、メンプールキャッシュを保持するフルノードは、コピーすべてを実際には`CheckTx`を実行する代わりに拒否します。コピーが`sequence`番号を増やしていても、攻撃者は手数料を支払う必要があるため、動機づけられます。

バリデータノードもフルノードと同様にリプレイ攻撃を防ぐためにメンプールを保持しますが、同時にブロックへの含まれる準備として確認されていないトランザクションのプールとしても使用します。なお、この段階で`Tx`がすべてのチェックに合格したとしても、後で無効と判断される可能性があります。なぜなら、`CheckTx`はトランザクションを完全に検証しないからです（つまり、実際にはメッセージを実行しません）。


## Inclusion in a Block

コンセンサスは、バリデータノードがどのトランザクションを受け入れるかに合意する過程で、**ラウンド**と呼ばれる単位で行われます。各ラウンドは、提案者が最新のトランザクションからブロックを作成し、**バリデータ**（コンセンサスを担当する投票権を持つ特別なフルノード）がそのブロックを受け入れるか、代わりに`nil`ブロックを選択することで終了します。バリデータノードはコンセンサスアルゴリズム（例：[CometBFT](https://docs.cometbft.com/v0.37/spec/consensus/)）を実行し、この合意に至るためにアプリケーションへABCIリクエストを使用してトランザクションを確認します。

コンセンサスの最初のステップは**ブロック提案**です。バリデータの中からコンセンサスアルゴリズムによって選ばれた1人の提案者が、ブロックを作成し提案します。`Tx`が含まれるためには、この提案者のメンプールに含まれている必要があります。

## State Changes

コンセンサスの次のステップは、トランザクションを実行して完全に検証することです。正しい提案者からブロック提案を受け取るすべてのフルノードは、ABCI関数`FinalizeBlock`を呼び出すことでトランザクションを実行します。
ドキュメント全体で述べられているように、`BeginBlock`、`ExecuteTx`、`EndBlock`はすべて`FinalizeBlock`内で呼び出されます。
各フルノードは個別にローカルに操作しますが、その結果は常に一貫して明確です。これは、メッセージによってもたらされるステートの変更が予測可能であり、トランザクションが提案されたブロック内で特定の順序で配置されているためです。

```text
		-----------------------
		|Receive Block Proposal|
		-----------------------
							|
				v
		-------------------------
		| FinalizeBlock	        |
		          |
			  v
				-------------------
				| BeginBlock	    | 
				-------------------
		          |
			  v
			--------------------
			| ExecuteTx(tx0)   |
			| ExecuteTx(tx1)   |
			| ExecuteTx(tx2)   |
			| ExecuteTx(tx3)   |
			|	.	      |
			|	.	      |
			|	.	      |
			-------------------
		          |
			  v
			--------------------
			| EndBlock	      |
			--------------------
		-------------------------
		          |
			  v
		-----------------------
		| Consensus	      |
		-----------------------
		          |
			  v
		-----------------------
		| Commit	      |
		-----------------------
```

### Transaction Execution

[`BaseApp`](../core/00-baseapp.md)で定義された`FinalizeBlock` ABCI関数は、ステートの大部分の遷移を行います。これは、コンセンサス中にコミットされた順序でブロック内の各トランザクションに対して順次実行されます。内部的には、トランザクションの実行はほぼ`CheckTx`と同じですが、チェックモードの代わりに実行モードである[`runTx`](../core/00-baseapp.md#runtx)関数を呼び出します。
フルノードは、`checkState`ではなく`finalizeblock`を使用します。

* **デコード:** `FinalizeBlock`はABCI呼び出しであるため、`Tx`はエンコードされた`[]byte`形式で受信されます。ノードはまずトランザクションをアンマーシャルし、アプリで定義された[`TxConfig`](./app-anatomy#register-codec)を使用して、その後`runTx`を`execModeFinalize`で呼び出します。これは`CheckTx`と非常に似ていますが、実際には実行とステートの変更も行います。

* **チェックと`AnteHandler`:** フルノードは再び`validateBasicMsgs`と`AnteHandler`を呼び出します。この2回目のチェックは、Mempoolへの追加時に同じトランザクションを見ていない可能性があるためであり、悪意のある提案者が無効なトランザクションを含めている可能性があります。ここでの違いは、`AnteHandler`がノードの`min-gas-prices`と`gas-prices`を比較しないことです。なぜならその値は各ノードごとに異なるためであり、ノード間で異なる値があると非決定的な結果が得られるからです。

* **`MsgServiceRouter`:** `CheckTx`が終了した後、`FinalizeBlock`は[`runMsgs`](../core/00-baseapp.md#runtx-antehandler-runmsgs-posthandler)を実行してトランザクション内の各`Msg`を完全に実行します。トランザクションには異なるモジュールからのメッセージが含まれている可能性があるため、`BaseApp`は適切なハンドラを見つけるためにどのモジュールを使用するかを知る必要があります。これは`BaseApp`の`MsgServiceRouter`を使用して実現され、モジュールのProtobuf [`Msg` サービス](../building-modules/03-msg-services.md)によって処理されるようになります。
`LegacyMsg`ルーティングでは、[モジュールマネージャ](../building-modules/01-module-manager.md)を介して`Route`関数が呼び出され、ルート名を取得し、モジュール内のレガシーな[`Handler`](../building-modules/03-msg-services.md#handler-type)を見つけます。
  
* **`Msg`サービス:** Protobuf `Msg`サービスは、各メッセージを`Tx`内で実行し、ステートの遷移を`finalizeBlockState`に永続化する責任があります。

* **PostHandlers:** [`PostHandler`](../core/00-baseapp.md#posthandler)は、メッセージの実行後に実行されます。もし失敗した場合、`runMsgs`のステート変更および`PostHandlers`のステート変更の両方が元に戻されます。

* **Gas:** `Tx`がデリバリーされている間、`GasMeter`はどれだけのガスが使用されているかを追跡するために使用されます。実行が完了すると、`GasUsed`が設定され、`abci.ExecTxResult`で返されます。もし実行が中断される場合、`BlockGasMeter`または`GasMeter`が枯渇したか、何か他の問題が発生した場合、最後に遅延実行される関数が適切にエラーまたはパニックを発生させます。

`Tx`が無効であるか、`GasMeter`が枯渇したために発生したステート変更がある場合、トランザクションの処理は中断され、ステートの変更は元に戻されます。提案されたブロック内の無効なトランザクションは、バリデータノードがブロックを拒否し、代わりに`nil`ブロックに投票する原因となります。



### Commit

最終ステップは、ノードがブロックとステート変更を確定することです。バリデータノードは、トランザクションを検証するためにステート遷移を実行し、その後ブロックに署名して確認します。バリデータでないフルノードはコンセンサスに参加せず、投票することはできませんが、ステート変更を確定すべきかどうかを理解するために投票を受信します。

バリデータの投票が十分に集まると（投票パワーで重み付けされた2/3以上の _precommit_）、フルノードは新しいブロックをコミットし、アプリケーション層でステート遷移を確定させます。新しいステートルートが生成され、ステート遷移のMerkleプルーフとして機能します。アプリケーションは、[Baseapp](../core/00-baseapp.md)から継承された[`Commit`](../core/00-baseapp.md#commit) ABCIメソッドを使用します。これにより、アプリケーションの内部ステートに`deliverState`を書き込むことで、すべてのステート遷移を同期させます。ステート変更が確定すると、`checkState`は最新の確定ステートから再起動し、`deliverState`は変更を反映し一貫性を保つために`nil`にリセットされます。

すべてのブロックが同じ数のトランザクションを持っているわけではなく、コンセンサスによって`nil`ブロックまたはまったくトランザクションのないブロックになる可能性があります。公開ブロックチェーンネットワークでは、バリデータが**ビザンチン**、または悪意のある振る舞いをする可能性があり、それによりトランザクションがブロックチェーンに確定されないことがあります。悪意のある振る舞いには、提案者がブロックから`Tx`を除外して検閲することや、バリデータがブロックに反対票を投じることなどがあります。

この時点で、`Tx`のトランザクションライフサイクルは終了です。ノードはその妥当性を検証し、ステート変更を実行して配信し、それらの変更を確定しました。`Tx`自体は、`[]byte`形式でブロックに保存され、ブロックチェーンに追加されます。
